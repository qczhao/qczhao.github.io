---
layout: post
title:  ".net异步编程的问题"
date:   2018-05-19 11:24:30 -0400
categories: 工作琐事
---

上周到这周，用新版的HttpClient库封装了调用Java管理Gerrit的函数，也通过了功能测试。但是这周，将它包装成一个Web api controller之后，前端调用却是无限的循环。追究根本，就是

参考一下这几个文章

> https://stackoverflow.com/questions/10343632/httpclient-getasync-never-returns-when-using-await-async
> https://stackoverflow.com/search?tab=votes&q=webapi%20httpclient
> http://blog.stephencleary.com/2012/07/dont-block-on-async-code.html

按照文章的说法，我进行功能测试的环境是Web Application，而转换为Web Api Controller之后。调用异步Api的进程不同，上下文不同，从而产生了死锁的问题

# Web Application调用的上下文，类似于传统的Win Form的UI Context
# Web Api调用的上线文，为ASP.NET request context

> an ASP.NET request context is not tied to a specific thread (like the UI context is), but it does only allow one thread in at a time. This interesting aspect is not officially documented anywhere AFAIK, but it is mentioned in my MSDN article about SynchronizationContext. https://msdn.microsoft.com/en-us/magazine/gg598924.aspx

So this is what happens, starting with the top-level method (Button1_Click for UI / MyController.Get for ASP.NET):

 - The top-level method calls GetJsonAsync (within the UI/ASP.NET context).
 - GetJsonAsync starts the REST request by calling HttpClient.GetStringAsync (still within the context).
 - GetStringAsync returns an uncompleted Task, indicating the REST request is not complete.
 - GetJsonAsync awaits the Task returned by GetStringAsync. The context is captured and will be used to continue running the GetJsonAsync method later. GetJsonAsync returns an uncompleted Task, indicating that the GetJsonAsync method is not complete.
 - The top-level method synchronously blocks on the Task returned by GetJsonAsync. This blocks the context thread.
 - … Eventually, the REST request will complete. This completes the Task that was returned by GetStringAsync.
 - The continuation for GetJsonAsync is now ready to run, and it waits for the context to be available so it can execute in the context.
 - Deadlock. The top-level method is blocking the context thread, waiting for GetJsonAsync to complete, and GetJsonAsync is waiting for the context to be free so it can complete.

For the UI example, the “context” is the UI context; for the ASP.NET example, the “context” is the ASP.NET request context. This type of deadlock can be caused for either “context”.

